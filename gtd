#!/bin/bash

set -e

# Configuration
CUSTOM_CMD="clear"
MPD_CMD="mpc -q toggle"
DEFAULT_WORK_LENGTH=15

if [[ "$OSTYPE" =~ (^darwin|^freebsd) ]]; then
   NOTIFY_CMD="echo"
   # NOTIFY_CMD="xmessage -center -timeout 5"
   SPEAK_CMD="&>/dev/null say"
else
   NOTIFY_CMD="notify-send"
   SPEAK_CMD="&>/dev/null espeak"
fi

NOTIFY_WORK="\"Get things done.\""
NOTIFY_BREAK="\"Take a break.\""

SPEAK_WORK="$NOTIFY_WORK"
SPEAK_BREAK="$NOTIFY_BREAK"

# Flag defaults
DO_BREAK=false
DO_CUSTOM_CMD=false
DO_MPD=false
DO_NOTIFY=false
DO_SPEAK=false
DO_TMUX=false

# Display help
usage() {
cat << EOF
USAGE:

   gtd [ -bcmnst ] [ work length ] [ break length ]

OPTIONS:

   -b : start on a break
   -c : custom command (defaults to "clear")
   -m : toggle MPD on change
   -n : notify on change
   -s : speak command
   -t : show time in tmux status bar

EOF
}

# Set flag options
while getopts "bcmnsth?" opt; do
   case $opt in
      b) DO_BREAK=true;;
      c) DO_CUSTOM_CMD=true;;
      m) DO_MPD=true;;
      n) DO_NOTIFY=true;;
      s) DO_SPEAK=true;;
      t) DO_TMUX=true;;
      *) usage; exit 1;;
   esac
done
shift $((OPTIND-1))

# Set work length if specified and is a number
if [ -z "$1" ]; then
   work_length=$DEFAULT_WORK_LENGTH
elif [ ! -z "${1##[0-9]*}" ]; then
   usage && exit 1
else
   work_length=$1
fi

# Set break length if specified and is a number
if [ -z "$2" ]; then
   break_length=$(( $work_length / 5 ))
elif [ ! -z "${2##[0-9]*}" ]; then
   usage && exit 1
else
   break_length=$2
fi

# Collect session statistics
total_working_time=0
num_breaks=0

# Displays milliseconds as HH:MM:SS
hms() {
   local S=$1
   ((h=S/3600))
   ((m=S%3600/60))
   ((s=S%60))
   printf "%02d:%02d:%02d\n" $h $m $s
}

# Displays a countdown using hms() while sleeping ("visual" sleep)
vsleep() {
   if [[ "$OSTYPE" =~ (^darwin|^freebsd) ]]; then
      now="date -j +%s"
      later=$(date -j -v+$1S +%s)
   else
      now="date +%s"
      later=$(date --date "now +$1 seconds" +%s)
   fi
   while [ $(eval $now) -lt $later ]; do
      left=$(( $later - $(eval $now) ))
      hms=$(hms $left)
      # Updates a temporary file for tmux to read from and refreshes the client
      if $DO_TMUX; then
         (echo -ne "$hms |" > /tmp/gtd)
         (tmux refresh-client -S)
      fi
      echo -e "$hms $(tput el)\r\c"
      sleep 1
   done
}

# Do various tasks based on the user-specified flags
do_options() {
   if $DO_CUSTOM_CMD; then eval "$CUSTOM_CMD"; fi
   if $DO_NOTIFY && $1; then eval "$NOTIFY_CMD $NOTIFY_BREAK";
   elif $DO_NOTIFY; then eval "$NOTIFY_CMD $NOTIFY_WORK"; fi
   if $DO_SPEAK && $1; then eval "$SPEAK_CMD $SPEAK_BREAK";
   elif $DO_SPEAK; then eval "$SPEAK_CMD $SPEAK_WORK"; fi
   if $DO_MPD; then (sleep 1 && eval "$MPD_CMD"); fi
}

# Clear the temporary file and refresh tmux when interrupted/terminated
[[ -z $DO_TMUX ]] && trap '>/tmp/gtd && tmux refresh-client -S' INT TERM

# Display the initial session settings
clear && echo "$work_length minute sessions with $break_length minute breaks."

# Loop through work and break cycles
while true; do
   if $DO_BREAK; then
      do_options true
      vsleep $(( $break_length * 60 ))
   else DO_BREAK=true; fi
   do_options false
   vsleep $(( $work_length * 60 ))
   total_working_time=$(( ($total_working_time + $work_length) ))
   num_breaks=$(( $num_breaks + 1 ))
   echo -e "Break #$num_breaks. Total working time: $(hms $(( $total_working_time * 60 )))"
done

exit 0
